{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computa\u00e7\u00e3o em Nuvem","text":"Edi\u00e7\u00e3o <p>2025.1</p>"},{"location":"#kit-n","title":"KIT-N","text":"<p>Luka Figueiredo</p> <p>Luiz Durand</p>"},{"location":"#entregas","title":"Entregas","text":"<ul> <li> Roteiro 1 - Data 21/03/2025</li> <li> Roteiro 2</li> <li> Roteiro 3</li> <li> Roteiro 4</li> <li> Projeto</li> </ul>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"roteiro1/main/","title":"Roteiro 1","text":""},{"location":"roteiro1/main/#objetivo","title":"Objetivo","text":"<p>Aqui vai o objetivo macro do roteiro. Por que estamos fazendo o que estamos fazendo?</p>"},{"location":"roteiro1/main/#infra","title":"Infra","text":"<p>Os pontos \"tarefas\" s\u00e3o os passos que devem ser seguidos para a realiza\u00e7\u00e3o do roteiro. Eles devem ser claros e objetivos. Com evid\u00eancias claras de que foram realizados.</p>"},{"location":"roteiro1/main/#tarefa-1","title":"Tarefa 1","text":"<p>Instalando o MAAS:</p> sudo snap install maas --channel=3.5/Stable <p></p> <p>Dashboard do MAAS</p> <p>Conforme ilustrado acima, a tela inicial do MAAS apresenta um dashboard com informa\u00e7\u00f5es sobre o estado atual dos servidores gerenciados. O dashboard \u00e9 composto por diversos pain\u00e9is, cada um exibindo informa\u00e7\u00f5es sobre um aspecto espec\u00edfico do ambiente gerenciado. Os pain\u00e9is podem ser configurados e personalizados de acordo com as necessidades do usu\u00e1rio.</p>"},{"location":"roteiro1/main/#tarefa-2","title":"Tarefa 2","text":""},{"location":"roteiro1/main/#app","title":"App","text":""},{"location":"roteiro1/main/#django-em-nuvem-bare-metal","title":"Django em Nuvem Bare-Metal","text":"<p>Postgres \u00e9 um servidor de banco de dados vers\u00e1til e de f\u00e1cil manejo. Muito usado em projetos Opensource e por isso vamos .</p> <p>Durante a configura\u00e7\u00e3o inicial da nossa nuvem MaaS, realizamos um deploy manual de uma aplica\u00e7\u00e3o simples em Django. Para garantir que o ambiente estivesse corretamente configurado, fizemos um pequeno ajuste no servidor DNS.</p> <p>Primeiramente, dentro da aba Subnets, acessamos a subnet <code>172.16.0.0/20</code> e editamos o Subnet Summary, substituindo o DNS pelo do Insper (<code>172.20.129.131</code>).</p>"},{"location":"roteiro1/main/#parte-1-banco-de-dados","title":"Parte 1: Banco de Dados","text":"<p>Primeiro Deploy</p> <p>Durante a configura\u00e7\u00e3o inicial da nossa nuvem MaaS, realizamos um deploy manual de uma aplica\u00e7\u00e3o simples em Django. Para garantir que o ambiente estivesse corretamente configurado, fizemos um pequeno ajuste no servidor DNS.</p> <p>Primeiramente, dentro da aba Subnets, acessamos a subnet <code>172.16.0.0/20</code> e editamos o Subnet Summary, substituindo o DNS pelo do Insper (<code>172.20.129.131</code>).</p> <p>Banco de Dados</p> <p>Como banco de dados, optamos pelo PostgreSQL, devido \u00e0 sua versatilidade e facilidade de manejo, sendo amplamente utilizado em projetos Open Source.</p> <p>Nosso primeiro passo foi acessar o Dashboard do MaaS e realizar o deploy do Ubuntu 22.04 no <code>server1</code>. Assim que a m\u00e1quina estava operacional, conectamos ao terminal via SSH e realizamos a instala\u00e7\u00e3o do PostgreSQL:</p> <pre><code>$ sudo apt update\n$ sudo apt install postgresql postgresql-contrib -y\n</code></pre> <p>Com o banco instalado, precis\u00e1vamos configurar um usu\u00e1rio para a aplica\u00e7\u00e3o. Para isso, acessamos o usu\u00e1rio <code>postgres</code>:</p> <pre><code>$ sudo su - postgres\n$ createuser -s cloud -W\n</code></pre> <p>Definimos a senha <code>cloud</code> e seguimos para a cria\u00e7\u00e3o do banco de dados:</p> <pre><code>$ createdb -O cloud tasks\n</code></pre> <p>Para garantir que o banco pudesse ser acessado remotamente dentro da rede, ajustamos os arquivos de configura\u00e7\u00e3o.</p> <p>No arquivo postgresql.conf, removemos o coment\u00e1rio da linha <code>listen_addresses</code> e a configuramos para aceitar conex\u00f5es externas:</p> <pre><code>$ nano /etc/postgresql/14/main/postgresql.conf\n</code></pre> <p>Modificamos a linha:</p> <pre><code>listen_addresses = '*'\n</code></pre> <p>Em seguida, editamos o arquivo pg_hba.conf para permitir conex\u00f5es de qualquer m\u00e1quina dentro da subnet do kit:</p> <pre><code>$ nano /etc/postgresql/14/main/pg_hba.conf\n</code></pre> <p>Adicionamos a seguinte linha:</p> <pre><code>host    all             all             172.16.0.0/20          trust\n</code></pre> <p>Ap\u00f3s essas configura\u00e7\u00f5es, sa\u00edmos do usu\u00e1rio <code>postgres</code> e liberamos a porta do banco no firewall:</p> <pre><code>$ sudo ufw allow 5432/tcp\n</code></pre> <p>Por fim, reiniciamos o servi\u00e7o para aplicar as altera\u00e7\u00f5es:</p> <pre><code>$ sudo systemctl restart postgresql\n</code></pre> <p>Essa configura\u00e7\u00e3o garantiu que o banco de dados estivesse pronto para ser utilizado pela aplica\u00e7\u00e3o Django em um ambiente bare-metal dentro da nossa nuvem MaaS.</p> <ol> <li>Funcionando e seu Status est\u00e1 como \"Ativo\" para o Sistema Operacional</li> </ol> <p>Usamos o comando: <pre><code>sudo systemctl status postgresql\n</code></pre> para verificar o status do  PostgreSQL  2. Acessivel na pr\u00f3pria maquina na qual ele foi implantado. Para verificar que esta acessivel na pr\u00f3pria maquina na qual ele foi implantado foi utilizado o comando: <pre><code>psql -U cloud -d tasks -h localhost\n</code></pre>  3. Acessivel a partir de uma conex\u00e3o vinda da m\u00e1quina MAIN. E para verificar que esta acessivel a partir de uma conex\u00e3o vinda da m\u00e1quina MAIN: <pre><code>telnet [IP do server1] 5432\n</code></pre></p> <p> 4. Em qual porta este servi\u00e7o est\u00e1 funcionando.</p> <p>Finalmente verificamos em qual porta o PostgreSQL est\u00e1 rodando com: <pre><code>sudo ss -tulnp | grep postgres\n</code></pre></p> <p></p>"},{"location":"roteiro1/main/#parte-2-implementacao-manual-da-aplicacao-django-e-banco-de-dados","title":"Parte 2: Implementa\u00e7\u00e3o Manual da Aplica\u00e7\u00e3o Django e Banco de Dados","text":"<p>Configura\u00e7\u00e3o do MaaS</p> <p>Para iniciar, acessei o MaaS e fiz login utilizando o CLI com o seguinte comando:</p> <pre><code>maas login [meu_usuario] http://172.16.0.3:5240/MAAS/\n</code></pre> <p>Em seguida, obtive o token no dashboard dentro das configura\u00e7\u00f5es do usu\u00e1rio. Com o token em m\u00e3os, solicitei a reserva de uma m\u00e1quina no MaaS:</p> <pre><code>maas [meu_usuario] machines allocate name=server2\n</code></pre> <p>A resposta retornou um JSON contendo v\u00e1rias informa\u00e7\u00f5es, entre elas o <code>system_id</code>, que anotei para uso posterior.</p> <p>Deploy da M\u00e1quina e Instala\u00e7\u00e3o da Aplica\u00e7\u00e3o</p> <p>Com o <code>system_id</code>, iniciei o deploy da m\u00e1quina via CLI:</p> <pre><code>maas [meu_usuario] machine deploy [system_id]\n</code></pre> <p>Assim que o deploy foi conclu\u00eddo, acessei a m\u00e1quina <code>server2</code> via SSH e clonei o reposit\u00f3rio do projeto Django:</p> <pre><code>git clone https://github.com/raulikeda/tasks.git\n</code></pre> <p>Naveguei at\u00e9 o diret\u00f3rio <code>tasks</code> e executei o script de instala\u00e7\u00e3o:</p> <pre><code>cd tasks\n./install.sh\n</code></pre> <p>Ap\u00f3s a instala\u00e7\u00e3o, reiniciei a m\u00e1quina e aguardei o processo de inicializa\u00e7\u00e3o.</p> <p>Teste do Servi\u00e7o</p> <p>Como server1 n\u00e3o estava registrado no DNS, adicionei-o manualmente ao arquivo <code>/etc/hosts</code> do server2: Apos a m\u00e1quina reiniciar adicionei manualmente o IP no <code>/etc/hosts</code></p> <pre><code>[IP_DO_SERVER1]  server1\n</code></pre> <p>Esta configura\u00e7\u00e3o permite que o server2 resolva o nome <code>server1</code> para o endere\u00e7o IP <code>192.168.1.100</code>, mesmo sem uma entrada correspondente no servidor DNS.</p> <p>Note</p> <p>Esta altera\u00e7\u00e3o \u00e9 local apenas para server2 e n\u00e3o afeta outros sistemas na rede.</p> <p>Para validar que a aplica\u00e7\u00e3o estava rodando corretamente, realizei um teste de acesso ao servi\u00e7o na porta 8080 diretamente do terminal do MaaS:</p> <pre><code>wget http://[IP_server2]:8080/admin/\n</code></pre> <p>Se o acesso fosse bem-sucedido, a interface de administra\u00e7\u00e3o do Django estaria funcionando corretamente.</p> <p>Exposi\u00e7\u00e3o do Servi\u00e7o via T\u00fanel SSH</p> <p>Para acessar a aplica\u00e7\u00e3o no navegador sem precisar configurar NAT no roteador, utilizei um t\u00fanel SSH. Primeiro, desconectei do SSH do MaaS e reconectei utilizando o seguinte comando:</p> <pre><code>ssh cloud@10.103.0.X -L 8001:[IP_server2]:8080\n</code></pre> <p>Esse comando criou um t\u00fanel, redirecionando o servi\u00e7o rodando na porta 8080 do <code>server2</code> para a porta 8001 no meu localhost. Certifiquei-me de que a porta 8001 n\u00e3o estava em uso antes de rodar o comando.</p> <p>Ent\u00e3o, acessei o Django Admin pelo navegador no seguinte endere\u00e7o:</p> <pre><code>http://localhost:8001/admin/\n</code></pre> <p>Fiz login com as credenciais padr\u00e3o:</p> <ul> <li>Usu\u00e1rio: cloud</li> <li>Senha: cloud</li> </ul> <p>Tarefa 2</p> <p>1.Dashboard do MAAS com as m\u00e1quinas.  2. Da aba images, com as imagens sincronizadas.  3. Aba de cada maquina(5x) mostrando os testes de hardware e commissioning com Status \"OK\"  </p>"},{"location":"roteiro1/main/#parte-3-status-dos-servidores","title":"Parte 3: Status dos servidores","text":"<p>Tarefa-3</p> <p>Prints Comprovando a Configura\u00e7\u00e3o</p> <ul> <li>Capturamos um print da tela do Dashboard do MAAS, mostrando as duas m\u00e1quinas configuradas com seus respectivos IPs. </li> <li>Registramos tamb\u00e9m um print da aplica\u00e7\u00e3o Django em execu\u00e7\u00e3o, comprovando a conex\u00e3o com o servidor. </li> <li>Explique como foi feita a implementacao manual da aplicacao Django e banco de dados.</li> </ul> <p>Implementa\u00e7\u00e3o Manual da Aplica\u00e7\u00e3o Django e Banco de Dados</p> <p>Inicialmente, configuramos uma \u00fanica aplica\u00e7\u00e3o Django. No entanto, percebemos a necessidade de expandir para dois servidores de aplica\u00e7\u00e3o (server2 e server3), ambos conectados a um \u00fanico banco de dados hospedado no server1. Essa estrat\u00e9gia foi adotada por dois motivos principais:</p> <ol> <li>Alta Disponibilidade: Caso um dos n\u00f3s falhe, o outro continua operacional, garantindo acesso cont\u00ednuo aos usu\u00e1rios.</li> <li>Balanceamento de Carga: Distribu\u00edmos as requisi\u00e7\u00f5es entre os servidores, melhorando a escalabilidade e o desempenho da aplica\u00e7\u00e3o.</li> </ol> <p>Para otimizar esse processo, decidimos automatizar a instala\u00e7\u00e3o e configura\u00e7\u00e3o usando o Ansible. Essa ferramenta facilitou a replica\u00e7\u00e3o do ambiente em m\u00faltiplos servidores, garantindo consist\u00eancia e reduzindo erros manuais.</p>"},{"location":"roteiro1/main/#parte-4-utilizando-o-ansible-deploy-automatizado-de-aplicacao","title":"Parte 4: Utilizando o Ansible - Deploy Automatizado de Aplica\u00e7\u00e3o","text":"<p>Configura\u00e7\u00e3o do Server3 e Deploy com Ansible</p> <p>Ap\u00f3s  para o maas via cli, igual feito anteriormente para o server2, realizamos a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ansible no servidor principal (main). Utilizamos o seguinte procedimento:</p> <ol> <li>Instalamos o Ansible:    <pre><code>sudo apt install ansible\n</code></pre></li> <li>Baixamos o playbook de instala\u00e7\u00e3o da aplica\u00e7\u00e3o Django:    <pre><code>wget https://raw.githubusercontent.com/raulikeda/tasks/master/tasks-install-playbook.yaml\n</code></pre></li> <li>Executamos o playbook para provisionar o server3 automaticamente:    <pre><code>ansible-playbook tasks-install-playbook.yaml --extra-vars server=[IP server3]\n</code></pre></li> </ol> <p>O Ansible garantiu que todos os procedimentos fossem executados de forma idempotente, ou seja, pod\u00edamos repetir o processo sem impactar negativamente o ambiente. Al\u00e9m disso, possibilitou a configura\u00e7\u00e3o simult\u00e2nea de m\u00faltiplos servidores, facilitando a expans\u00e3o da infraestrutura.</p> <p>Tarefa 4</p> <ol> <li>Tela do Dashboard do MAAS com as 3 Maquinas e seus respectivos IPs. </li> <li>Aplicacao Django, provando que voce est\u00e1 conectado ao server2  </li> <li>Aplicacao Django, provando que voce est\u00e1 conectado ao server3  </li> <li>Diferenca entre instalar manualmente a aplicacao Django e utilizando o Ansible.</li> </ol> <p>Com essa abordagem, conseguimos implementar uma solu\u00e7\u00e3o escal\u00e1vel e confi\u00e1vel para nossa aplica\u00e7\u00e3o Django. A automa\u00e7\u00e3o proporcionada pelo Ansible simplificou o gerenciamento dos servidores e garantiu que a aplica\u00e7\u00e3o estivesse sempre dispon\u00edvel e distribu\u00edda adequadamente.</p>"},{"location":"roteiro1/main/#parte-4-balanceamento-de-carga-com-nginx","title":"Parte 4: Balanceamento de Carga com NGINX","text":"<p>Nossa Implementa\u00e7\u00e3o com NGINX</p> <p>Instala\u00e7\u00e3o do NGINX</p> <p>Primeiramentea foi feito o deploy e instala\u00e7\u00e3o do NGINX no servidor <code>server4</code> para atuar como nosso balanceador de carga:</p> <pre><code>sudo apt update\nsudo apt install nginx -y\n</code></pre> <p>Configura\u00e7\u00e3o do M\u00f3dulo Upstream</p> <p>Para configurar o balanceamento round robin, utilizamos o m\u00f3dulo upstream do NGINX. Editamos o arquivo de configura\u00e7\u00e3o do site padr\u00e3o:</p> <pre><code>sudo nano /etc/nginx/sites-available/default\n</code></pre> <p>Adicionamos a configura\u00e7\u00e3o do balanceamento de carga da seguinte forma:</p> <pre><code>upstream backend {\n    server [IP_DO_SERVER2] :8080;\n    server [IP_DO_SERVER3] :8080;\n}\n\n\nserver {\n    location / {\n        proxy_pass http://backend;\n    }\n}\n</code></pre> <p>Ap\u00f3s salvar as altera\u00e7\u00f5es, reiniciamos o servi\u00e7o do NGINX:</p> <p><pre><code>sudo service nginx restart\n</code></pre> Tarefa 5</p> <ol> <li> <p>De um print da tela do Dashboard do MAAS com as 4 Maquinas e seus respectivos IPs.  Personaliza\u00e7\u00e3o das Aplica\u00e7\u00f5es Django</p> </li> <li> <p>Alteramos o conte\u00fado da mensagem contida na fun\u00e7\u00e3o <code>index</code> do arquivo <code>tasks/views.py</code> de cada server para distinguir ambos os servers. </p> </li> </ol> <p>Para podermos identificar facilmente qual servidor estava respondendo a cada requisi\u00e7\u00e3o, modificamos o arquivo <code>tasks/views.py</code> em cada inst\u00e2ncia Django, alterando a mensagem de resposta para algo \u00fanico em cada servidor:</p> <p><pre><code># Em server1\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\ndef index(request):\n    return HttpResponse(\"Hello, world. You're at server 2.\")\n</code></pre> </p> <p><pre><code># Em server2\nfrom django.shortcuts import render\nfrom django.http import HttpResponse\n\ndef index(request):\n    return HttpResponse(\"Hello, world. You're at server 2.\")\n</code></pre> </p> <ol> <li> <p>Fa\u00e7a um <code>GET request</code> para o path que voce criou em urls.py para o Nginx e tire 2 prints das respostas de cada request, provando que voce est\u00e1 conectado ao server 4, que \u00e9 o Proxy Reverso e que ele bate cada vez em um server diferente server2 e server3.</p> </li> <li> <p>As respostas de cada request do server 4, mostram que cada vez que um <code>GET request</code> \u00e9 feito ele bate cada vez em um server diferente server2 e server3.  </p> </li> </ol>"},{"location":"roteiro2/main/","title":"Relat\u00f3rio - Roteiro 2: Gerenciamento de Aplica\u00e7\u00f5es com Juju","text":""},{"location":"roteiro2/main/#objetivo","title":"Objetivo","text":"<p>O objetivo deste roteiro \u00e9 explorar o orquestrador Juju para gerenciar aplica\u00e7\u00f5es em ambientes de nuvem. Atrav\u00e9s do Juju, buscamos:</p> <ol> <li>Simplificar o deploy e gerenciamento de aplica\u00e7\u00f5es complexas  </li> <li>Implementar solu\u00e7\u00f5es de monitoramento com Prometheus e Grafana  </li> <li>Gerenciar relacionamentos entre servi\u00e7os de forma declarativa  </li> <li>Automatizar a configura\u00e7\u00e3o de ambientes escal\u00e1veis  </li> </ol>"},{"location":"roteiro2/main/#infra","title":"Infra","text":""},{"location":"roteiro2/main/#configuracao-inicial-do-ambiente-juju","title":"Configura\u00e7\u00e3o Inicial do Ambiente Juju","text":"<ol> <li>Instala\u00e7\u00e3o do Juju: <pre><code>sudo snap install juju --channel 3.6\n</code></pre> Depois, verificamos que o Juju reconhece o MaaS como provedor de recursos com: <pre><code>juju clouds\n</code></pre></li> </ol> <p>Como o MaaS n\u00e3o apareceu na lista de clouds do Juju, adicionamos o manualmente usando um arquivo YAML.</p> <p><pre><code>nano maas-cloud.yaml\n</code></pre> <pre><code>clouds:\n  my-maas:\n    type: maas\n    auth-types: [oauth1]\n    endpoint: http://&lt;SEU_IP_MAAS&gt;:5240/MAAS\n</code></pre> <pre><code>juju add-cloud --client my-maas maas-cloud.yaml\n</code></pre></p> <p>Adicionamos as credenciais MAAS para que o Juju possa interagir com a nova cloud adicionada. <pre><code>credentials:\n  maas-one:\n    anyuser:\n      auth-type: oauth1\n      maas-oauth: &lt;API KEY&gt;\n</code></pre> <pre><code>juju add-credential --client -f maas-creds.yaml maas-one\n</code></pre></p>"},{"location":"roteiro2/main/#criacao-do-controlador","title":"Cria\u00e7\u00e3o do Controlador","text":"<p>Para criar o controlador no <code>server1</code>, primeiro colocamos a tag \"juju\" na m\u00e1quina pelo painel do MAAS. Depois, executamos:</p> <pre><code>juju bootstrap --bootstrap-series=jammy --constraints tags=juju maas-one maas-controller\n</code></pre> <p>Esse processo pode demorar, pois o Juju precisa provisionar uma m\u00e1quina, instalar pacotes e configurar servi\u00e7os. Para acompanhar o progresso, utilizamos e deixaremos esse terminal aberto daqui em diante:</p> <pre><code>watch -n 1 --color 'juju status --color'\n</code></pre>"},{"location":"roteiro2/main/#app","title":"App","text":"<p><pre><code>juju add-model --config default-series=jammy openstack\njuju switch controller\njuju deploy juju-dashboard --to lxd:0\njuju intergrate juju-dashboard controller\n</code></pre> Cria o modelo openstack com a s\u00e9rie padr\u00e3o jammy. Troca para o modelo controller. Implanta o painel do Juju (juju-dashboard) em um container da m\u00e1quina 0. Integra o painel ao controlador para gerenciar os modelos via interface web.</p> <p><pre><code>juju enable-dashboard\njuju dashboard\n</code></pre> Ativa a interface web do Juju. Exibe o link de acesso e credenciais para login.</p> <p><pre><code>mkdir -p /home/cloud/charms\ncd /home/cloud/charms\n</code></pre> Cria e acessa o diret\u00f3rio onde os charms ser\u00e3o armazenados.</p> <p><pre><code>juju download grafana\njuju download prometheus2\n</code></pre> Baixa os charms Grafana e Prometheus2 localmente para futura implanta\u00e7\u00e3o.</p> <pre><code>juju switch openstack\njuju deploy ./prometheus2_r60.charm\njuju deploy grafana\n</code></pre> <p>Troca para o modelo openstack. Implanta o Prometheus2 a partir do arquivo .charm baixado. Implanta o Grafana diretamente do reposit\u00f3rio de charms.</p> <p><pre><code>juju intergrate grafana:grafana-source prometheus2:grafana-source\n</code></pre> Conecta Grafana ao Prometheus, permitindo uso das m\u00e9tricas como fonte de dados.</p> <p><pre><code>juju expose grafana\njuju expose prometheus2\n</code></pre> Libera acesso externo aos servi\u00e7os via rede.</p> <p>Acessamos o Grafana via navegador:</p> <p>Obtemos o IP da m\u00e1quina do grafana com juju status</p> <p>Acessamos http://:3000 e fizemos login com a senha resultante dessa linha <p><pre><code>juju run grafana/0 get-admin-password\n</code></pre> Fa\u00e7a login e configure seu dashboard!</p>"},{"location":"roteiro2/main/#tarefas","title":"Tarefas","text":""}]}